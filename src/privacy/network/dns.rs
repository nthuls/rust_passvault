// src/privacy/network/dns.rs
use serde::{Serialize, Deserialize};
use std::path::PathBuf;
use std::fs;
use std::process::Command;
use super::super::PrivacyError;
use utoipa::ToSchema;

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct DnsSettings {
    pub use_dns_over_https: bool,
    pub use_dns_over_tls: bool,
    pub custom_dns_server: Option<String>,
    pub block_malware_domains: bool,
    pub block_ads: bool,
    pub block_trackers: bool,
}

pub struct DnsConfigurator {
    config_dir: PathBuf,
}

impl DnsConfigurator {
    pub fn new() -> Result<Self, PrivacyError> {
        // Get app config directory
        let config_dir = crate::utils::get_app_config_dir()
            .ok_or_else(|| PrivacyError::IoError(std::io::Error::new(
                std::io::ErrorKind::NotFound,
                "Config directory not found"
            )))?;
        
        // Create DNS config directory
        let dns_dir = config_dir.join("dns");
        if !dns_dir.exists() {
            fs::create_dir_all(&dns_dir)?;
        }
        
        Ok(Self { config_dir: dns_dir })
    }
    
    // Apply DNS settings
    pub fn apply_settings(&self, settings: &DnsSettings) -> Result<(), PrivacyError> {
        // Check for DNSCrypt-Proxy
        let dnscrypt_available = Self::is_dnscrypt_available();
        
        if settings.use_dns_over_https || settings.use_dns_over_tls {
            if !dnscrypt_available {
                return Err(PrivacyError::BrowserError(
                    "DNSCrypt-Proxy is required for DNS-over-HTTPS/TLS but was not found".to_string()
                ));
            }
            
            // Generate DNSCrypt-Proxy configuration
            self.generate_dnscrypt_config(settings)?;
            
            // Restart DNSCrypt-Proxy service
            self.restart_dnscrypt_service()?;
        } else {
            // Use regular DNS with custom server if specified
            if let Some(dns_server) = &settings.custom_dns_server {
                // Set system DNS server - this is OS specific
                self.set_system_dns(dns_server)?;
            }
        }
        
        Ok(())
    }
    
    // Check if DNSCrypt-Proxy is available
    fn is_dnscrypt_available() -> bool {
        Command::new("dnscrypt-proxy")
            .arg("--version")
            .status()
            .map(|status| status.success())
            .unwrap_or(false)
    }
    
    // Generate DNSCrypt-Proxy configuration
    fn generate_dnscrypt_config(&self, settings: &DnsSettings) -> Result<(), PrivacyError> {
        let config_path = self.config_dir.join("dnscrypt-proxy.toml");
        
        // This is a simplified configuration; a real implementation would be more complex
        let mut config = String::new();
        
        config.push_str("# DNSCrypt-Proxy configuration generated by RustVault\n\n");
        config.push_str("listen_addresses = ['127.0.0.1:53']\n");
        
        // Use DNS-over-HTTPS or DNS-over-TLS
        if settings.use_dns_over_https {
            config.push_str("server_names = ['cloudflare', 'cloudflare-ipv6']\n");
        } else if settings.use_dns_over_tls {
            config.push_str("server_names = ['cloudflare-tls', 'cloudflare-tls-ipv6']\n");
        }
        
        // Custom DNS server
        if let Some(dns_server) = &settings.custom_dns_server {
            config.push_str(&format!("bootstrap_resolvers = ['{}']\n", dns_server));
        }
        
        // Blocking options
        if settings.block_malware_domains || settings.block_ads || settings.block_trackers {
            config.push_str("\n[blocked_names]\n");
            
            if settings.block_malware_domains {
                config.push_str("  blocked_names_file = 'blocked-malware.txt'\n");
            }
            
            if settings.block_ads {
                config.push_str("  blocked_names_file = 'blocked-ads.txt'\n");
            }
            
            if settings.block_trackers {
                config.push_str("  blocked_names_file = 'blocked-trackers.txt'\n");
            }
        }
        
        // Write the configuration file
        fs::write(config_path, config)?;
        
        Ok(())
    }
    
    // Restart the DNSCrypt-Proxy service
    fn restart_dnscrypt_service(&self) -> Result<(), PrivacyError> {
        // This is highly OS-dependent; here's a simplified example
        // In a real implementation, you'd need to handle different OSes
        
        #[cfg(target_os = "linux")]
        {
            // Try systemd first
            let systemd_result = Command::new("systemctl")
                .args(["restart", "dnscrypt-proxy"])
                .status();
            
            if systemd_result.is_ok() && systemd_result.unwrap().success() {
                return Ok(());
            }
            
            // Try service command
            let service_result = Command::new("service")
                .args(["dnscrypt-proxy", "restart"])
                .status();
            
            if service_result.is_ok() && service_result.unwrap().success() {
                return Ok(());
            }
            
            // As a last resort, try running it directly
            let config_path = self.config_dir.join("dnscrypt-proxy.toml");
            let _ = Command::new("dnscrypt-proxy")
                .arg("-config")
                .arg(config_path)
                .spawn();
        }
        
        #[cfg(target_os = "macos")]
        {
            // Try launchctl
            let _ = Command::new("launchctl")
                .args(["unload", "/Library/LaunchDaemons/com.dnscrypt-proxy.plist"])
                .status();
            
            let _ = Command::new("launchctl")
                .args(["load", "/Library/LaunchDaemons/com.dnscrypt-proxy.plist"])
                .status();
        }
        
        #[cfg(target_os = "windows")]
        {
            // Try Windows service
            let _ = Command::new("net")
                .args(["stop", "dnscrypt-proxy"])
                .status();
                
            let _ = Command::new("net")
                .args(["start", "dnscrypt-proxy"])
                .status();
        }
        
        Ok(())
    }
    
    // Set system DNS server
    fn set_system_dns(&self, dns_server: &str) -> Result<(), PrivacyError> {
        // This is highly OS-dependent; here's a simplified example
        
        #[cfg(target_os = "linux")]
        {
            // Try NetworkManager
            let _ = Command::new("nmcli")
                .args(["con", "mod", "System", "ipv4.dns", dns_server])
                .status();
                
            let _ = Command::new("nmcli")
                .args(["con", "up", "System"])
                .status();
        }
        
        #[cfg(target_os = "macos")]
        {
            // Get current network service
            let output = Command::new("networksetup")
                .args(["-listallnetworkservices"])
                .output()?;
            
            let services = String::from_utf8_lossy(&output.stdout);
            // Skip the first line which is just a header
            let service = services.lines().nth(1).unwrap_or("Wi-Fi");
            
            let _ = Command::new("networksetup")
                .args(["-setdnsservers", service, dns_server])
                .status();
        }
        
        #[cfg(target_os = "windows")]
        {
            // Windows needs more complex PowerShell commands to set DNS
            // This is a simplified example
            let _ = Command::new("powershell")
                .args([
                    "-Command",
                    &format!("Set-DnsClientServerAddress -InterfaceAlias Wi-Fi -ServerAddresses {}", dns_server)
                ])
                .status();
        }
        
        Ok(())
    }
}